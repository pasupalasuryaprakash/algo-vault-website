
import { DSAQuestion } from "@/pages/Index";

export const initialDSAQuestions: Omit<DSAQuestion, "id" | "createdAt">[] = [
  // Easy Questions (35 questions)
  {
    title: "Two Sum",
    description: "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",
    difficulty: "Easy",
    topic: "Arrays",
    tags: ["hash-table", "array"],
    solution: "def twoSum(nums, target):\n    hash_map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in hash_map:\n            return [hash_map[complement], i]\n        hash_map[num] = i\n    return []",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    notes: "Use hash map to store visited numbers and their indices. For each number, check if its complement exists in the hash map."
  },
  {
    title: "Valid Parentheses",
    description: "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.",
    difficulty: "Easy",
    topic: "Stack",
    tags: ["stack", "string"],
    solution: "def isValid(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in mapping:\n            if not stack or stack.pop() != mapping[char]:\n                return False\n        else:\n            stack.append(char)\n    return not stack",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    notes: "Use stack to keep track of opening brackets. When encountering closing bracket, check if it matches the most recent opening bracket."
  },
  {
    title: "Merge Two Sorted Lists",
    description: "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list.",
    difficulty: "Easy",
    topic: "Linked Lists",
    tags: ["linked-list", "recursion"],
    solution: "def mergeTwoLists(list1, list2):\n    dummy = ListNode(0)\n    current = dummy\n    while list1 and list2:\n        if list1.val <= list2.val:\n            current.next = list1\n            list1 = list1.next\n        else:\n            current.next = list2\n            list2 = list2.next\n        current = current.next\n    current.next = list1 or list2\n    return dummy.next",
    timeComplexity: "O(m + n)",
    spaceComplexity: "O(1)",
    notes: "Use dummy node to simplify edge cases. Compare values and attach smaller node to result list."
  },
  {
    title: "Maximum Subarray",
    description: "Given an integer array nums, find the contiguous subarray which has the largest sum and return its sum.",
    difficulty: "Easy",
    topic: "Dynamic Programming",
    tags: ["array", "dynamic-programming"],
    solution: "def maxSubArray(nums):\n    max_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    return max_sum",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    notes: "Kadane's algorithm: at each position, decide whether to start new subarray or extend current one."
  },
  {
    title: "Best Time to Buy and Sell Stock",
    description: "You are given an array prices where prices[i] is the price of a given stock on the ith day. Find the maximum profit.",
    difficulty: "Easy",
    topic: "Arrays",
    tags: ["array", "dynamic-programming"],
    solution: "def maxProfit(prices):\n    min_price = float('inf')\n    max_profit = 0\n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n    return max_profit",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    notes: "Track minimum price seen so far and calculate profit if selling at current price."
  },
  {
    title: "Binary Search",
    description: "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums.",
    difficulty: "Easy",
    topic: "Binary Search",
    tags: ["array", "binary-search"],
    solution: "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
    timeComplexity: "O(log n)",
    spaceComplexity: "O(1)",
    notes: "Classic binary search: divide search space in half at each iteration."
  },
  {
    title: "Reverse Linked List",
    description: "Given the head of a singly linked list, reverse the list, and return the reversed list.",
    difficulty: "Easy",
    topic: "Linked Lists",
    tags: ["linked-list", "recursion"],
    solution: "def reverseList(head):\n    prev = None\n    current = head\n    while current:\n        next_temp = current.next\n        current.next = prev\n        prev = current\n        current = next_temp\n    return prev",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    notes: "Iteratively reverse pointers: maintain three pointers (prev, current, next)."
  },
  {
    title: "Contains Duplicate",
    description: "Given an integer array nums, return true if any value appears at least twice in the array.",
    difficulty: "Easy",
    topic: "Arrays",
    tags: ["array", "hash-table"],
    solution: "def containsDuplicate(nums):\n    return len(nums) != len(set(nums))",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    notes: "Convert to set and compare lengths, or use hash set to track seen elements."
  },
  {
    title: "Valid Anagram",
    description: "Given two strings s and t, return true if t is an anagram of s, and false otherwise.",
    difficulty: "Easy",
    topic: "Strings",
    tags: ["hash-table", "string", "sorting"],
    solution: "def isAnagram(s, t):\n    return sorted(s) == sorted(t)",
    timeComplexity: "O(n log n)",
    spaceComplexity: "O(1)",
    notes: "Sort both strings and compare, or use character frequency counting."
  },
  {
    title: "Palindrome Number",
    description: "Given an integer x, return true if x is palindrome integer.",
    difficulty: "Easy",
    topic: "Math",
    tags: ["math"],
    solution: "def isPalindrome(x):\n    if x < 0:\n        return False\n    original = x\n    reversed_num = 0\n    while x > 0:\n        reversed_num = reversed_num * 10 + x % 10\n        x //= 10\n    return original == reversed_num",
    timeComplexity: "O(log n)",
    spaceComplexity: "O(1)",
    notes: "Reverse the number mathematically and compare with original."
  },
  {
    title: "Remove Duplicates from Sorted Array",
    description: "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place.",
    difficulty: "Easy",
    topic: "Arrays",
    tags: ["array", "two-pointers"],
    solution: "def removeDuplicates(nums):\n    if not nums:\n        return 0\n    write_index = 1\n    for i in range(1, len(nums)):\n        if nums[i] != nums[i-1]:\n            nums[write_index] = nums[i]\n            write_index += 1\n    return write_index",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    notes: "Two pointers: one for reading, one for writing unique elements."
  },
  {
    title: "Climbing Stairs",
    description: "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    difficulty: "Easy",
    topic: "Dynamic Programming",
    tags: ["math", "dynamic-programming", "memoization"],
    solution: "def climbStairs(n):\n    if n <= 2:\n        return n\n    first, second = 1, 2\n    for i in range(3, n + 1):\n        first, second = second, first + second\n    return second",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    notes: "Fibonacci sequence: ways to reach step n = ways to reach (n-1) + ways to reach (n-2)."
  },
  {
    title: "Valid Palindrome",
    description: "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward.",
    difficulty: "Easy",
    topic: "Strings",
    tags: ["two-pointers", "string"],
    solution: "def isPalindrome(s):\n    left, right = 0, len(s) - 1\n    while left < right:\n        while left < right and not s[left].isalnum():\n            left += 1\n        while left < right and not s[right].isalnum():\n            right -= 1\n        if s[left].lower() != s[right].lower():\n            return False\n        left += 1\n        right -= 1\n    return True",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    notes: "Two pointers approach: skip non-alphanumeric characters and compare."
  },
  {
    title: "Invert Binary Tree",
    description: "Given the root of a binary tree, invert the tree, and return its root.",
    difficulty: "Easy",
    topic: "Binary Trees",
    tags: ["tree", "depth-first-search", "breadth-first-search"],
    solution: "def invertTree(root):\n    if not root:\n        return None\n    root.left, root.right = root.right, root.left\n    invertTree(root.left)\n    invertTree(root.right)\n    return root",
    timeComplexity: "O(n)",
    spaceComplexity: "O(h)",
    notes: "Recursively swap left and right children for each node."
  },
  {
    title: "Symmetric Tree",
    description: "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).",
    difficulty: "Easy",
    topic: "Binary Trees",
    tags: ["tree", "depth-first-search", "breadth-first-search"],
    solution: "def isSymmetric(root):\n    def isMirror(left, right):\n        if not left and not right:\n            return True\n        if not left or not right:\n            return False\n        return (left.val == right.val and \n                isMirror(left.left, right.right) and \n                isMirror(left.right, right.left))\n    return isMirror(root.left, root.right)",
    timeComplexity: "O(n)",
    spaceComplexity: "O(h)",
    notes: "Recursively check if left subtree is mirror of right subtree."
  },
  {
    title: "Maximum Depth of Binary Tree",
    description: "Given the root of a binary tree, return its maximum depth.",
    difficulty: "Easy",
    topic: "Binary Trees",
    tags: ["tree", "depth-first-search", "breadth-first-search"],
    solution: "def maxDepth(root):\n    if not root:\n        return 0\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))",
    timeComplexity: "O(n)",
    spaceComplexity: "O(h)",
    notes: "Recursively calculate depth: 1 + maximum depth of left and right subtrees."
  },
  {
    title: "Same Tree",
    description: "Given the roots of two binary trees p and q, write a function to check if they are the same or not.",
    difficulty: "Easy",
    topic: "Binary Trees",
    tags: ["tree", "depth-first-search"],
    solution: "def isSameTree(p, q):\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    return (p.val == q.val and \n            isSameTree(p.left, q.left) and \n            isSameTree(p.right, q.right))",
    timeComplexity: "O(n)",
    spaceComplexity: "O(h)",
    notes: "Recursively compare values and structure of both trees."
  },
  {
    title: "Path Sum",
    description: "Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.",
    difficulty: "Easy",
    topic: "Binary Trees",
    tags: ["tree", "depth-first-search"],
    solution: "def hasPathSum(root, targetSum):\n    if not root:\n        return False\n    if not root.left and not root.right:\n        return root.val == targetSum\n    return (hasPathSum(root.left, targetSum - root.val) or \n            hasPathSum(root.right, targetSum - root.val))",
    timeComplexity: "O(n)",
    spaceComplexity: "O(h)",
    notes: "DFS: subtract current value from target and check children."
  },
  {
    title: "Minimum Depth of Binary Tree",
    description: "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.",
    difficulty: "Easy",
    topic: "Binary Trees",
    tags: ["tree", "depth-first-search", "breadth-first-search"],
    solution: "def minDepth(root):\n    if not root:\n        return 0\n    if not root.left:\n        return 1 + minDepth(root.right)\n    if not root.right:\n        return 1 + minDepth(root.left)\n    return 1 + min(minDepth(root.left), minDepth(root.right))",
    timeComplexity: "O(n)",
    spaceComplexity: "O(h)",
    notes: "Handle edge cases where one child is None, then take minimum of both subtrees."
  },
  {
    title: "Balanced Binary Tree",
    description: "Given a binary tree, determine if it is height-balanced. A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.",
    difficulty: "Easy",
    topic: "Binary Trees",
    tags: ["tree", "depth-first-search"],
    solution: "def isBalanced(root):\n    def height(node):\n        if not node:\n            return 0\n        left_height = height(node.left)\n        if left_height == -1:\n            return -1\n        right_height = height(node.right)\n        if right_height == -1:\n            return -1\n        if abs(left_height - right_height) > 1:\n            return -1\n        return 1 + max(left_height, right_height)\n    return height(root) != -1",
    timeComplexity: "O(n)",
    spaceComplexity: "O(h)",
    notes: "Calculate height and check balance condition simultaneously. Return -1 if unbalanced."
  },
  {
    title: "Convert Sorted Array to Binary Search Tree",
    description: "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.",
    difficulty: "Easy",
    topic: "Binary Trees",
    tags: ["array", "divide-and-conquer", "tree"],
    solution: "def sortedArrayToBST(nums):\n    def helper(left, right):\n        if left > right:\n            return None\n        mid = (left + right) // 2\n        root = TreeNode(nums[mid])\n        root.left = helper(left, mid - 1)\n        root.right = helper(mid + 1, right)\n        return root\n    return helper(0, len(nums) - 1)",
    timeComplexity: "O(n)",
    spaceComplexity: "O(log n)",
    notes: "Use divide and conquer: middle element as root, recursively build left and right subtrees."
  },
  {
    title: "Pascal's Triangle",
    description: "Given an integer numRows, return the first numRows of Pascal's triangle.",
    difficulty: "Easy",
    topic: "Arrays",
    tags: ["array", "dynamic-programming"],
    solution: "def generate(numRows):\n    triangle = []\n    for i in range(numRows):\n        row = [1] * (i + 1)\n        for j in range(1, i):\n            row[j] = triangle[i-1][j-1] + triangle[i-1][j]\n        triangle.append(row)\n    return triangle",
    timeComplexity: "O(numRows²)",
    spaceComplexity: "O(numRows²)",
    notes: "Each element is sum of two elements above it in previous row."
  },
  {
    title: "Pascal's Triangle II",
    description: "Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.",
    difficulty: "Easy",
    topic: "Arrays",
    tags: ["array", "dynamic-programming"],
    solution: "def getRow(rowIndex):\n    row = [1] * (rowIndex + 1)\n    for i in range(1, rowIndex + 1):\n        for j in range(i - 1, 0, -1):\n            row[j] += row[j - 1]\n    return row",
    timeComplexity: "O(rowIndex²)",
    spaceComplexity: "O(rowIndex)",
    notes: "Build row in-place by updating from right to left to avoid overwriting needed values."
  },
  {
    title: "Single Number",
    description: "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.",
    difficulty: "Easy",
    topic: "Bit Manipulation",
    tags: ["array", "bit-manipulation"],
    solution: "def singleNumber(nums):\n    result = 0\n    for num in nums:\n        result ^= num\n    return result",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    notes: "XOR all numbers: identical numbers cancel out, leaving only the unique number."
  },
  {
    title: "Linked List Cycle",
    description: "Given head, the head of a linked list, determine if the linked list has a cycle in it.",
    difficulty: "Easy",
    topic: "Linked Lists",
    tags: ["hash-table", "linked-list", "two-pointers"],
    solution: "def hasCycle(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    notes: "Floyd's cycle detection: slow pointer moves 1 step, fast moves 2 steps. If cycle exists, they'll meet."
  },
  {
    title: "Min Stack",
    description: "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
    difficulty: "Easy",
    topic: "Stack",
    tags: ["stack", "design"],
    solution: "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n    \n    def push(self, val):\n        self.stack.append(val)\n        if not self.min_stack or val <= self.min_stack[-1]:\n            self.min_stack.append(val)\n    \n    def pop(self):\n        if self.stack.pop() == self.min_stack[-1]:\n            self.min_stack.pop()\n    \n    def top(self):\n        return self.stack[-1]\n    \n    def getMin(self):\n        return self.min_stack[-1]",
    timeComplexity: "O(1)",
    spaceComplexity: "O(n)",
    notes: "Use auxiliary stack to track minimum values. Push to min_stack when new minimum found."
  },
  {
    title: "Intersection of Two Linked Lists",
    description: "Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect.",
    difficulty: "Easy",
    topic: "Linked Lists",
    tags: ["hash-table", "linked-list", "two-pointers"],
    solution: "def getIntersectionNode(headA, headB):\n    if not headA or not headB:\n        return None\n    pointerA, pointerB = headA, headB\n    while pointerA != pointerB:\n        pointerA = pointerA.next if pointerA else headB\n        pointerB = pointerB.next if pointerB else headA\n    return pointerA",
    timeComplexity: "O(m + n)",
    spaceComplexity: "O(1)",
    notes: "Two pointers traverse both lists. When reaching end, switch to other list's head."
  },
  {
    title: "Excel Sheet Column Title",
    description: "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.",
    difficulty: "Easy",
    topic: "Math",
    tags: ["math", "string"],
    solution: "def convertToTitle(columnNumber):\n    result = \"\"\n    while columnNumber > 0:\n        columnNumber -= 1\n        result = chr(columnNumber % 26 + ord('A')) + result\n        columnNumber //= 26\n    return result",
    timeComplexity: "O(log n)",
    spaceComplexity: "O(log n)",
    notes: "Convert to base-26 with 1-indexing: subtract 1 before each division."
  },
  {
    title: "Majority Element",
    description: "Given an array nums of size n, return the majority element. The majority element is the element that appears more than ⌊n / 2⌋ times.",
    difficulty: "Easy",
    topic: "Arrays",
    tags: ["array", "hash-table", "divide-and-conquer", "sorting", "counting"],
    solution: "def majorityElement(nums):\n    count = 0\n    candidate = None\n    for num in nums:\n        if count == 0:\n            candidate = num\n        count += 1 if num == candidate else -1\n    return candidate",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    notes: "Boyer-Moore majority vote algorithm: maintain candidate and count. Majority element will survive."
  },
  {
    title: "Excel Sheet Column Number",
    description: "Given a string columnTitle that represents the column title as appear in an Excel sheet, return its corresponding column number.",
    difficulty: "Easy",
    topic: "Math",
    tags: ["math", "string"],
    solution: "def titleToNumber(columnTitle):\n    result = 0\n    for char in columnTitle:\n        result = result * 26 + (ord(char) - ord('A') + 1)\n    return result",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    notes: "Convert from base-26 to decimal: multiply by 26 and add current digit value."
  },
  {
    title: "Factorial Trailing Zeroes",
    description: "Given an integer n, return the number of trailing zeroes in n!.",
    difficulty: "Easy",
    topic: "Math",
    tags: ["math"],
    solution: "def trailingZeroes(n):\n    count = 0\n    while n >= 5:\n        n //= 5\n        count += n\n    return count",
    timeComplexity: "O(log n)",
    spaceComplexity: "O(1)",
    notes: "Count factors of 5 in n! (factors of 2 are more abundant). Include 25, 125, etc."
  },
  {
    title: "Binary Tree Paths",
    description: "Given the root of a binary tree, return all root-to-leaf paths in any order.",
    difficulty: "Easy",
    topic: "Binary Trees",
    tags: ["string", "backtracking", "tree", "depth-first-search"],
    solution: "def binaryTreePaths(root):\n    def dfs(node, path, result):\n        if not node:\n            return\n        path.append(str(node.val))\n        if not node.left and not node.right:\n            result.append('->'.join(path))\n        else:\n            dfs(node.left, path, result)\n            dfs(node.right, path, result)\n        path.pop()\n    \n    result = []\n    dfs(root, [], result)\n    return result",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    notes: "DFS with backtracking: build path and add to result when reaching leaf."
  },
  {
    title: "Add Digits",
    description: "Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.",
    difficulty: "Easy",
    topic: "Math",
    tags: ["math", "simulation", "number-theory"],
    solution: "def addDigits(num):\n    if num == 0:\n        return 0\n    return 1 + (num - 1) % 9",
    timeComplexity: "O(1)",
    spaceComplexity: "O(1)",
    notes: "Digital root formula: 1 + (n-1) % 9 for n > 0. Based on number theory."
  },
  {
    title: "Ugly Number",
    description: "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. Given an integer n, return true if n is an ugly number.",
    difficulty: "Easy",
    topic: "Math",
    tags: ["math"],
    solution: "def isUgly(n):\n    if n <= 0:\n        return False\n    for factor in [2, 3, 5]:\n        while n % factor == 0:\n            n //= factor\n    return n == 1",
    timeComplexity: "O(log n)",
    spaceComplexity: "O(1)",
    notes: "Divide by 2, 3, 5 as much as possible. If result is 1, number is ugly."
  },
  {
    title: "Missing Number",
    description: "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.",
    difficulty: "Easy",
    topic: "Arrays",
    tags: ["array", "hash-table", "math", "bit-manipulation", "sorting"],
    solution: "def missingNumber(nums):\n    n = len(nums)\n    return n * (n + 1) // 2 - sum(nums)",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    notes: "Sum of 0 to n minus sum of array gives missing number. Can also use XOR."
  },
  {
    title: "Move Zeroes",
    description: "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.",
    difficulty: "Easy",
    topic: "Arrays",
    tags: ["array", "two-pointers"],
    solution: "def moveZeroes(nums):\n    write_index = 0\n    for read_index in range(len(nums)):\n        if nums[read_index] != 0:\n            nums[write_index] = nums[read_index]\n            write_index += 1\n    while write_index < len(nums):\n        nums[write_index] = 0\n        write_index += 1",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    notes: "Two pointers: write non-zero elements to front, then fill remaining with zeros."
  },

  // Medium Questions (40 questions)
  {
    title: "Add Two Numbers",
    description: "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.",
    difficulty: "Medium",
    topic: "Linked Lists",
    tags: ["linked-list", "math", "recursion"],
    solution: "def addTwoNumbers(l1, l2):\n    dummy = ListNode(0)\n    current = dummy\n    carry = 0\n    while l1 or l2 or carry:\n        val1 = l1.val if l1 else 0\n        val2 = l2.val if l2 else 0\n        total = val1 + val2 + carry\n        carry = total // 10\n        current.next = ListNode(total % 10)\n        current = current.next\n        l1 = l1.next if l1 else None\n        l2 = l2.next if l2 else None\n    return dummy.next",
    timeComplexity: "O(max(m, n))",
    spaceComplexity: "O(max(m, n))",
    notes: "Simulate addition digit by digit, handling carry. Continue until both lists exhausted and no carry."
  },
  {
    title: "Longest Substring Without Repeating Characters",
    description: "Given a string s, find the length of the longest substring without repeating characters.",
    difficulty: "Medium",
    topic: "Strings",
    tags: ["hash-table", "string", "sliding-window"],
    solution: "def lengthOfLongestSubstring(s):\n    char_map = {}\n    left = max_length = 0\n    for right, char in enumerate(s):\n        if char in char_map and char_map[char] >= left:\n            left = char_map[char] + 1\n        char_map[char] = right\n        max_length = max(max_length, right - left + 1)\n    return max_length",
    timeComplexity: "O(n)",
    spaceComplexity: "O(min(m, n))",
    notes: "Sliding window with hash map. Move left pointer when duplicate found."
  },
  {
    title: "3Sum",
    description: "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.",
    difficulty: "Medium",
    topic: "Arrays",
    tags: ["array", "two-pointers", "sorting"],
    solution: "def threeSum(nums):\n    nums.sort()\n    result = []\n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            if total < 0:\n                left += 1\n            elif total > 0:\n                right -= 1\n            else:\n                result.append([nums[i], nums[left], nums[right]])\n                while left < right and nums[left] == nums[left+1]:\n                    left += 1\n                while left < right and nums[right] == nums[right-1]:\n                    right -= 1\n                left += 1\n                right -= 1\n    return result",
    timeComplexity: "O(n²)",
    spaceComplexity: "O(1)",
    notes: "Sort array, then for each element, use two pointers to find remaining two elements. Skip duplicates."
  },
  {
    title: "Container With Most Water",
    description: "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container that contains the most water.",
    difficulty: "Medium",
    topic: "Arrays",
    tags: ["array", "two-pointers", "greedy"],
    solution: "def maxArea(height):\n    left, right = 0, len(height) - 1\n    max_water = 0\n    while left < right:\n        width = right - left\n        current_water = width * min(height[left], height[right])\n        max_water = max(max_water, current_water)\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_water",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    notes: "Two pointers: always move pointer with smaller height inward to potentially find larger area."
  },
  {
    title: "Longest Palindromic Substring",
    description: "Given a string s, return the longest palindromic substring in s.",
    difficulty: "Medium",
    topic: "Strings",
    tags: ["string", "dynamic-programming"],
    solution: "def longestPalindrome(s):\n    def expand_around_center(left, right):\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        return right - left - 1\n    \n    start = 0\n    max_len = 0\n    for i in range(len(s)):\n        len1 = expand_around_center(i, i)\n        len2 = expand_around_center(i, i + 1)\n        current_max = max(len1, len2)\n        if current_max > max_len:\n            max_len = current_max\n            start = i - (current_max - 1) // 2\n    return s[start:start + max_len]",
    timeComplexity: "O(n²)",
    spaceComplexity: "O(1)",
    notes: "Expand around center: check both odd and even length palindromes from each position."
  },
  {
    title: "Generate Parentheses",
    description: "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
    difficulty: "Medium",
    topic: "Backtracking",
    tags: ["string", "dynamic-programming", "backtracking"],
    solution: "def generateParenthesis(n):\n    def backtrack(current, open_count, close_count):\n        if len(current) == 2 * n:\n            result.append(current)\n            return\n        if open_count < n:\n            backtrack(current + '(', open_count + 1, close_count)\n        if close_count < open_count:\n            backtrack(current + ')', open_count, close_count + 1)\n    \n    result = []\n    backtrack('', 0, 0)\n    return result",
    timeComplexity: "O(4ⁿ / √n)",
    spaceComplexity: "O(4ⁿ / √n)",
    notes: "Backtracking: add opening bracket if under limit, add closing bracket if it won't exceed opening brackets."
  },
  {
    title: "Letter Combinations of a Phone Number",
    description: "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.",
    difficulty: "Medium",
    topic: "Backtracking",
    tags: ["hash-table", "string", "backtracking"],
    solution: "def letterCombinations(digits):\n    if not digits:\n        return []\n    phone = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl',\n             '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n    \n    def backtrack(index, current):\n        if index == len(digits):\n            result.append(current)\n            return\n        for letter in phone[digits[index]]:\n            backtrack(index + 1, current + letter)\n    \n    result = []\n    backtrack(0, '')\n    return result",
    timeComplexity: "O(3ⁿ × 4ᵐ)",
    spaceComplexity: "O(3ⁿ × 4ᵐ)",
    notes: "Backtracking: for each digit, try all possible letters and recurse to next digit."
  },
  {
    title: "Remove Nth Node From End of List",
    description: "Given the head of a linked list, remove the nth node from the end of the list and return its head.",
    difficulty: "Medium",
    topic: "Linked Lists",
    tags: ["linked-list", "two-pointers"],
    solution: "def removeNthFromEnd(head, n):\n    dummy = ListNode(0)\n    dummy.next = head\n    first = second = dummy\n    for _ in range(n + 1):\n        first = first.next\n    while first:\n        first = first.next\n        second = second.next\n    second.next = second.next.next\n    return dummy.next",
    timeComplexity: "O(L)",
    spaceComplexity: "O(1)",
    notes: "Two pointers with n+1 gap. When first reaches end, second is at node before target."
  },
  {
    title: "Valid Sudoku",
    description: "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain digits 1-9 without repetition, each column must contain digits 1-9 without repetition, each of the nine 3x3 sub-boxes must contain digits 1-9 without repetition.",
    difficulty: "Medium",
    topic: "Hash Table",
    tags: ["array", "hash-table"],
    solution: "def isValidSudoku(board):\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n    \n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == '.':\n                continue\n            val = board[i][j]\n            box_index = (i // 3) * 3 + j // 3\n            if val in rows[i] or val in cols[j] or val in boxes[box_index]:\n                return False\n            rows[i].add(val)\n            cols[j].add(val)\n            boxes[box_index].add(val)\n    return True",
    timeComplexity: "O(1)",
    spaceComplexity: "O(1)",
    notes: "Use sets to track seen values in each row, column, and 3x3 box. Box index = (row//3)*3 + col//3."
  },
  {
    title: "Combination Sum",
    description: "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target.",
    difficulty: "Medium",
    topic: "Backtracking",
    tags: ["array", "backtracking"],
    solution: "def combinationSum(candidates, target):\n    def backtrack(start, current, remaining):\n        if remaining == 0:\n            result.append(current[:])\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] <= remaining:\n                current.append(candidates[i])\n                backtrack(i, current, remaining - candidates[i])\n                current.pop()\n    \n    result = []\n    backtrack(0, [], target)\n    return result",
    timeComplexity: "O(N^(T/M))",
    spaceComplexity: "O(T/M)",
    notes: "Backtracking with reuse allowed. Start from current index to avoid duplicates in different orders."
  },
  {
    title: "First Missing Positive",
    description: "Given an unsorted integer array nums, return the smallest missing positive integer.",
    difficulty: "Medium",
    topic: "Arrays",
    tags: ["array", "hash-table"],
    solution: "def firstMissingPositive(nums):\n    n = len(nums)\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n    \n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    return n + 1",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    notes: "Use array itself as hash table. Place each number at its correct index (number x at index x-1)."
  },
  {
    title: "Trapping Rain Water",
    description: "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
    difficulty: "Medium",
    topic: "Arrays",
    tags: ["array", "two-pointers", "dynamic-programming", "stack", "monotonic-stack"],
    solution: "def trap(height):\n    left, right = 0, len(height) - 1\n    left_max = right_max = water = 0\n    while left < right:\n        if height[left] < height[right]:\n            if height[left] >= left_max:\n                left_max = height[left]\n            else:\n                water += left_max - height[left]\n            left += 1\n        else:\n            if height[right] >= right_max:\n                right_max = height[right]\n            else:\n                water += right_max - height[right]\n            right -= 1\n    return water",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    notes: "Two pointers: water level at position is minimum of max heights on left and right sides."
  },
  {
    title: "Permutations",
    description: "Given an array nums of distinct integers, return all the possible permutations.",
    difficulty: "Medium",
    topic: "Backtracking",
    tags: ["array", "backtracking"],
    solution: "def permute(nums):\n    def backtrack(current):\n        if len(current) == len(nums):\n            result.append(current[:])\n            return\n        for num in nums:\n            if num not in current:\n                current.append(num)\n                backtrack(current)\n                current.pop()\n    \n    result = []\n    backtrack([])\n    return result",
    timeComplexity: "O(n! × n)",
    spaceComplexity: "O(n)",
    notes: "Backtracking: build permutation by adding unused numbers, backtrack when complete."
  },
  {
    title: "Rotate Image",
    description: "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).",
    difficulty: "Medium",
    topic: "Arrays",
    tags: ["array", "math", "matrix"],
    solution: "def rotate(matrix):\n    n = len(matrix)\n    # Transpose\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    # Reverse each row\n    for i in range(n):\n        matrix[i].reverse()",
    timeComplexity: "O(n²)",
    spaceComplexity: "O(1)",
    notes: "Two steps: transpose matrix (swap along diagonal), then reverse each row."
  },
  {
    title: "Group Anagrams",
    description: "Given an array of strings strs, group the anagrams together.",
    difficulty: "Medium",
    topic: "Hash Table",
    tags: ["array", "hash-table", "string", "sorting"],
    solution: "def groupAnagrams(strs):\n    from collections import defaultdict\n    groups = defaultdict(list)\n    for s in strs:\n        key = tuple(sorted(s))\n        groups[key].append(s)\n    return list(groups.values())",
    timeComplexity: "O(N × K log K)",
    spaceComplexity: "O(N × K)",
    notes: "Group strings by their sorted characters as key. Anagrams have same sorted key."
  },
  {
    title: "Pow(x, n)",
    description: "Implement pow(x, n), which calculates x raised to the power n.",
    difficulty: "Medium",
    topic: "Math",
    tags: ["math", "recursion"],
    solution: "def myPow(x, n):\n    if n == 0:\n        return 1\n    if n < 0:\n        x = 1 / x\n        n = -n\n    result = 1\n    current_power = x\n    while n > 0:\n        if n % 2 == 1:\n            result *= current_power\n        current_power *= current_power\n        n //= 2\n    return result",
    timeComplexity: "O(log n)",
    spaceComplexity: "O(1)",
    notes: "Binary exponentiation: repeatedly square base and halve exponent. Handle negative exponents."
  },
  {
    title: "Spiral Matrix",
    description: "Given an m x n matrix, return all elements of the matrix in spiral order.",
    difficulty: "Medium",
    topic: "Arrays",
    tags: ["array", "matrix", "simulation"],
    solution: "def spiralOrder(matrix):\n    if not matrix:\n        return []\n    result = []\n    top, bottom, left, right = 0, len(matrix) - 1, 0, len(matrix[0]) - 1\n    \n    while top <= bottom and left <= right:\n        # Right\n        for col in range(left, right + 1):\n            result.append(matrix[top][col])\n        top += 1\n        # Down\n        for row in range(top, bottom + 1):\n            result.append(matrix[row][right])\n        right -= 1\n        # Left\n        if top <= bottom:\n            for col in range(right, left - 1, -1):\n                result.append(matrix[bottom][col])\n            bottom -= 1\n        # Up\n        if left <= right:\n            for row in range(bottom, top - 1, -1):\n                result.append(matrix[row][left])\n            left += 1\n    return result",
    timeComplexity: "O(m × n)",
    spaceComplexity: "O(1)",
    notes: "Maintain four boundaries and traverse in spiral order: right, down, left, up."
  },
  {
    title: "Jump Game",
    description: "You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index.",
    difficulty: "Medium",
    topic: "Greedy",
    tags: ["array", "dynamic-programming", "greedy"],
    solution: "def canJump(nums):\n    max_reach = 0\n    for i, jump in enumerate(nums):\n        if i > max_reach:\n            return False\n        max_reach = max(max_reach, i + jump)\n        if max_reach >= len(nums) - 1:\n            return True\n    return True",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    notes: "Greedy: track maximum reachable position. If current position exceeds max reach, impossible."
  },
  {
    title: "Merge Intervals",
    description: "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals.",
    difficulty: "Medium",
    topic: "Arrays",
    tags: ["array", "sorting"],
    solution: "def merge(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    \n    for current in intervals[1:]:\n        last = merged[-1]\n        if current[0] <= last[1]:\n            last[1] = max(last[1], current[1])\n        else:\n            merged.append(current)\n    return merged",
    timeComplexity: "O(n log n)",
    spaceComplexity: "O(1)",
    notes: "Sort by start time, then merge overlapping intervals by checking if current start <= previous end."
  },
  {
    title: "Unique Paths",
    description: "There is a robot on an m x n grid. The robot is initially located at the top-left corner. The robot tries to move to the bottom-right corner. The robot can only move either down or right at any point in time. How many possible unique paths are there?",
    difficulty: "Medium",
    topic: "Dynamic Programming",
    tags: ["math", "dynamic-programming", "combinatorics"],
    solution: "def uniquePaths(m, n):\n    dp = [[1] * n for _ in range(m)]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[m-1][n-1]",
    timeComplexity: "O(m × n)",
    spaceComplexity: "O(m × n)",
    notes: "DP: paths to cell = paths from above + paths from left. First row and column are all 1s."
  },
  {
    title: "Minimum Path Sum",
    description: "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.",
    difficulty: "Medium",
    topic: "Dynamic Programming",
    tags: ["array", "dynamic-programming", "matrix"],
    solution: "def minPathSum(grid):\n    m, n = len(grid), len(grid[0])\n    for i in range(m):\n        for j in range(n):\n            if i == 0 and j == 0:\n                continue\n            elif i == 0:\n                grid[i][j] += grid[i][j-1]\n            elif j == 0:\n                grid[i][j] += grid[i-1][j]\n            else:\n                grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n    return grid[m-1][n-1]",
    timeComplexity: "O(m × n)",
    spaceComplexity: "O(1)",
    notes: "DP in-place: minimum path sum to cell = current value + minimum of top and left neighbors."
  },
  {
    title: "Set Matrix Zeroes",
    description: "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.",
    difficulty: "Medium",
    topic: "Arrays",
    tags: ["array", "hash-table", "matrix"],
    solution: "def setZeroes(matrix):\n    m, n = len(matrix), len(matrix[0])\n    first_row_zero = any(matrix[0][j] == 0 for j in range(n))\n    first_col_zero = any(matrix[i][0] == 0 for i in range(m))\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][j] == 0:\n                matrix[i][0] = matrix[0][j] = 0\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][0] == 0 or matrix[0][j] == 0:\n                matrix[i][j] = 0\n    \n    if first_row_zero:\n        for j in range(n):\n            matrix[0][j] = 0\n    if first_col_zero:\n        for i in range(m):\n            matrix[i][0] = 0",
    timeComplexity: "O(m × n)",
    spaceComplexity: "O(1)",
    notes: "Use first row and column as markers for zero positions. Handle first row/column separately."
  },
  {
    title: "Search a 2D Matrix",
    description: "Write an efficient algorithm that searches for a value target in an m x n integer matrix. The matrix has properties: integers in each row are sorted from left to right, the first integer of each row is greater than the last integer of the previous row.",
    difficulty: "Medium",
    topic: "Binary Search",
    tags: ["array", "binary-search", "matrix"],
    solution: "def searchMatrix(matrix, target):\n    if not matrix or not matrix[0]:\n        return False\n    m, n = len(matrix), len(matrix[0])\n    left, right = 0, m * n - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        mid_value = matrix[mid // n][mid % n]\n        if mid_value == target:\n            return True\n        elif mid_value < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False",
    timeComplexity: "O(log(m × n))",
    spaceComplexity: "O(1)",
    notes: "Treat 2D matrix as 1D sorted array. Convert 1D index to 2D: row = idx // n, col = idx % n."
  },
  {
    title: "Sort Colors",
    description: "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.",
    difficulty: "Medium",
    topic: "Arrays",
    tags: ["array", "two-pointers", "sorting"],
    solution: "def sortColors(nums):\n    red = white = 0\n    blue = len(nums) - 1\n    \n    while white <= blue:\n        if nums[white] == 0:\n            nums[red], nums[white] = nums[white], nums[red]\n            red += 1\n            white += 1\n        elif nums[white] == 1:\n            white += 1\n        else:\n            nums[white], nums[blue] = nums[blue], nums[white]\n            blue -= 1",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    notes: "Dutch flag algorithm: maintain three pointers for 0s, 1s, and 2s regions."
  },
  {
    title: "Subsets",
    description: "Given an integer array nums of unique elements, return all possible subsets (the power set).",
    difficulty: "Medium",
    topic: "Backtracking",
    tags: ["array", "backtracking", "bit-manipulation"],
    solution: "def subsets(nums):\n    def backtrack(start, current):\n        result.append(current[:])\n        for i in range(start, len(nums)):\n            current.append(nums[i])\n            backtrack(i + 1, current)\n            current.pop()\n    \n    result = []\n    backtrack(0, [])\n    return result",
    timeComplexity: "O(n × 2ⁿ)",
    spaceComplexity: "O(n × 2ⁿ)",
    notes: "Backtracking: for each element, decide to include or exclude it in current subset."
  },
  {
    title: "Word Search",
    description: "Given an m x n grid of characters board and a string word, return true if word exists in the grid.",
    difficulty: "Medium",
    topic: "Backtracking",
    tags: ["array", "backtracking", "matrix"],
    solution: "def exist(board, word):\n    def dfs(i, j, index):\n        if index == len(word):\n            return True\n        if (i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or \n            board[i][j] != word[index]):\n            return False\n        \n        temp = board[i][j]\n        board[i][j] = '#'\n        found = (dfs(i+1, j, index+1) or dfs(i-1, j, index+1) or\n                 dfs(i, j+1, index+1) or dfs(i, j-1, index+1))\n        board[i][j] = temp\n        return found\n    \n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if dfs(i, j, 0):\n                return True\n    return False",
    timeComplexity: "O(m × n × 4^L)",
    spaceComplexity: "O(L)",
    notes: "DFS with backtracking: mark visited cells, explore all directions, restore state."
  },
  {
    title: "Remove Duplicates from Sorted Array II",
    description: "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice.",
    difficulty: "Medium",
    topic: "Arrays",
    tags: ["array", "two-pointers"],
    solution: "def removeDuplicates(nums):\n    if len(nums) <= 2:\n        return len(nums)\n    write_index = 2\n    for read_index in range(2, len(nums)):\n        if nums[read_index] != nums[write_index - 2]:\n            nums[write_index] = nums[read_index]\n            write_index += 1\n    return write_index",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    notes: "Two pointers: allow element if it's different from element two positions back."
  },
  {
    title: "Search in Rotated Sorted Array",
    description: "There is an integer array nums sorted in ascending order (with distinct values). Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k. Given the array after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.",
    difficulty: "Medium",
    topic: "Binary Search",
    tags: ["array", "binary-search"],
    solution: "def search(nums, target):\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        \n        if nums[left] <= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return -1",
    timeComplexity: "O(log n)",
    spaceComplexity: "O(1)",
    notes: "Modified binary search: determine which half is sorted, then check if target is in that range."
  },
  {
    title: "Find First and Last Position of Element in Sorted Array",
    description: "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.",
    difficulty: "Medium",
    topic: "Binary Search",
    tags: ["array", "binary-search"],
    solution: "def searchRange(nums, target):\n    def findFirst(nums, target):\n        left, right = 0, len(nums) - 1\n        result = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                result = mid\n                right = mid - 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return result\n    \n    def findLast(nums, target):\n        left, right = 0, len(nums) - 1\n        result = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                result = mid\n                left = mid + 1\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return result\n    \n    return [findFirst(nums, target), findLast(nums, target)]",
    timeComplexity: "O(log n)",
    spaceComplexity: "O(1)",
    notes: "Two binary searches: one to find first occurrence, one to find last occurrence."
  },
  {
    title: "Combination Sum II",
    description: "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination.",
    difficulty: "Medium",
    topic: "Backtracking",
    tags: ["array", "backtracking"],
    solution: "def combinationSum2(candidates, target):\n    def backtrack(start, current, remaining):\n        if remaining == 0:\n            result.append(current[:])\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            if candidates[i] > remaining:\n                break\n            current.append(candidates[i])\n            backtrack(i + 1, current, remaining - candidates[i])\n            current.pop()\n    \n    candidates.sort()\n    result = []\n    backtrack(0, [], target)\n    return result",
    timeComplexity: "O(2ⁿ)",
    spaceComplexity: "O(target)",
    notes: "Sort array, skip duplicates at same level, each element used at most once."
  },
  {
    title: "Gray Code",
    description: "An n-bit gray code sequence is a sequence of 2ⁿ integers where: every integer is in the inclusive range [0, 2ⁿ - 1], the first integer is 0, an integer appears no more than once in the sequence, the binary representation of every pair of adjacent integers differs by exactly one bit, the binary representation of the first and last integers also differs by exactly one bit.",
    difficulty: "Medium",
    topic: "Bit Manipulation",
    tags: ["math", "backtracking", "bit-manipulation"],
    solution: "def grayCode(n):\n    result = [0]\n    for i in range(n):\n        result += [x + (1 << i) for x in reversed(result)]\n    return result",
    timeComplexity: "O(2ⁿ)",
    spaceComplexity: "O(2ⁿ)",
    notes: "Build iteratively: for each bit position, mirror existing sequence and set that bit in mirrored part."
  },
  {
    title: "Subsets II",
    description: "Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets.",
    difficulty: "Medium",
    topic: "Backtracking",
    tags: ["array", "backtracking", "bit-manipulation"],
    solution: "def subsetsWithDup(nums):\n    def backtrack(start, current):\n        result.append(current[:])\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            current.append(nums[i])\n            backtrack(i + 1, current)\n            current.pop()\n    \n    nums.sort()\n    result = []\n    backtrack(0, [])\n    return result",
    timeComplexity: "O(n × 2ⁿ)",
    spaceComplexity: "O(n × 2ⁿ)",
    notes: "Sort array to group duplicates, skip duplicates at same recursion level."
  },
  {
    title: "Decode Ways",
    description: "A message containing letters from A-Z can be encoded into numbers using the mapping: 'A' -> '1', 'B' -> '2', ..., 'Z' -> '26'. To decode an encoded message, all the digits must be grouped then mapped back into letters. Given a string s containing only digits, return the number of ways to decode it.",
    difficulty: "Medium",
    topic: "Dynamic Programming",
    tags: ["string", "dynamic-programming"],
    solution: "def numDecodings(s):\n    if not s or s[0] == '0':\n        return 0\n    \n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = dp[1] = 1\n    \n    for i in range(2, n + 1):\n        if s[i-1] != '0':\n            dp[i] += dp[i-1]\n        if s[i-2] != '0' and int(s[i-2:i]) <= 26:\n            dp[i] += dp[i-2]\n    \n    return dp[n]",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    notes: "DP: ways to decode string = ways if last digit alone + ways if last two digits together (if valid)."
  },
  {
    title: "Reverse Linked List II",
    description: "Given the head of a singly linked list and two integers left and right where left <= right, reverse the nodes of the list from position left to position right, and return the reversed list.",
    difficulty: "Medium",
    topic: "Linked Lists",
    tags: ["linked-list"],
    solution: "def reverseBetween(head, left, right):\n    dummy = ListNode(0)\n    dummy.next = head\n    prev = dummy\n    \n    for _ in range(left - 1):\n        prev = prev.next\n    \n    current = prev.next\n    for _ in range(right - left):\n        next_node = current.next\n        current.next = next_node.next\n        next_node.next = prev.next\n        prev.next = next_node\n    \n    return dummy.next",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    notes: "Find start position, then repeatedly move next node to front of reversed section."
  },
  {
    title: "Restore IP Addresses",
    description: "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s.",
    difficulty: "Medium",
    topic: "Backtracking",
    tags: ["string", "backtracking"],
    solution: "def restoreIpAddresses(s):\n    def is_valid(segment):\n        return (len(segment) == 1 or \n                (segment[0] != '0' and int(segment) <= 255))\n    \n    def backtrack(start, path):\n        if len(path) == 4:\n            if start == len(s):\n                result.append('.'.join(path))\n            return\n        \n        for i in range(start, min(start + 3, len(s))):\n            segment = s[start:i+1]\n            if is_valid(segment):\n                path.append(segment)\n                backtrack(i + 1, path)\n                path.pop()\n    \n    result = []\n    backtrack(0, [])\n    return result",
    timeComplexity: "O(1)",
    spaceComplexity: "O(1)",
    notes: "Backtracking: try all valid segments (1-3 digits), check constraints for valid IP."
  },
  {
    title: "Binary Tree Inorder Traversal",
    description: "Given the root of a binary tree, return the inorder traversal of its nodes' values.",
    difficulty: "Medium",
    topic: "Binary Trees",
    tags: ["stack", "tree", "depth-first-search"],
    solution: "def inorderTraversal(root):\n    result = []\n    stack = []\n    current = root\n    \n    while stack or current:\n        while current:\n            stack.append(current)\n            current = current.left\n        current = stack.pop()\n        result.append(current.val)\n        current = current.right\n    \n    return result",
    timeComplexity: "O(n)",
    spaceComplexity: "O(h)",
    notes: "Iterative approach using stack: go left as far as possible, process node, then go right."
  },
  {
    title: "Unique Binary Search Trees",
    description: "Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.",
    difficulty: "Medium",
    topic: "Dynamic Programming",
    tags: ["math", "dynamic-programming", "tree", "binary-search-tree"],
    solution: "def numTrees(n):\n    dp = [0] * (n + 1)\n    dp[0] = dp[1] = 1\n    \n    for nodes in range(2, n + 1):\n        for root in range(1, nodes + 1):\n            left = root - 1\n            right = nodes - root\n            dp[nodes] += dp[left] * dp[right]\n    \n    return dp[n]",
    timeComplexity: "O(n²)",
    spaceComplexity: "O(n)",
    notes: "Catalan numbers: for each root position, multiply left subtree possibilities by right subtree possibilities."
  },
  {
    title: "Validate Binary Search Tree",
    description: "Given the root of a binary tree, determine if it is a valid binary search tree (BST).",
    difficulty: "Medium",
    topic: "Binary Trees",
    tags: ["tree", "depth-first-search", "binary-search-tree"],
    solution: "def isValidBST(root):\n    def validate(node, min_val, max_val):\n        if not node:\n            return True\n        if node.val <= min_val or node.val >= max_val:\n            return False\n        return (validate(node.left, min_val, node.val) and\n                validate(node.right, node.val, max_val))\n    \n    return validate(root, float('-inf'), float('inf'))",
    timeComplexity: "O(n)",
    spaceComplexity: "O(h)",
    notes: "Pass valid range down recursively: left subtree values < root < right subtree values."
  },

  // Hard Questions (25 questions)
  {
    title: "Median of Two Sorted Arrays",
    description: "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.",
    difficulty: "Hard",
    topic: "Binary Search",
    tags: ["array", "binary-search", "divide-and-conquer"],
    solution: "def findMedianSortedArrays(nums1, nums2):\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    \n    m, n = len(nums1), len(nums2)\n    left, right = 0, m\n    \n    while left <= right:\n        partition1 = (left + right) // 2\n        partition2 = (m + n + 1) // 2 - partition1\n        \n        max_left1 = float('-inf') if partition1 == 0 else nums1[partition1 - 1]\n        min_right1 = float('inf') if partition1 == m else nums1[partition1]\n        \n        max_left2 = float('-inf') if partition2 == 0 else nums2[partition2 - 1]\n        min_right2 = float('inf') if partition2 == n else nums2[partition2]\n        \n        if max_left1 <= min_right2 and max_left2 <= min_right1:\n            if (m + n) % 2 == 0:\n                return (max(max_left1, max_left2) + min(min_right1, min_right2)) / 2\n            else:\n                return max(max_left1, max_left2)\n        elif max_left1 > min_right2:\n            right = partition1 - 1\n        else:\n            left = partition1 + 1",
    timeComplexity: "O(log(min(m, n)))",
    spaceComplexity: "O(1)",
    notes: "Binary search on smaller array to find correct partition. Median is from elements around partition."
  },
  {
    title: "Regular Expression Matching",
    description: "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where '.' matches any single character and '*' matches zero or more of the preceding element.",
    difficulty: "Hard",
    topic: "Dynamic Programming",
    tags: ["string", "dynamic-programming", "recursion"],
    solution: "def isMatch(s, p):\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    \n    for j in range(2, n + 1):\n        if p[j-1] == '*':\n            dp[0][j] = dp[0][j-2]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j-1] == '*':\n                dp[i][j] = dp[i][j-2] or (dp[i-1][j] and (s[i-1] == p[j-2] or p[j-2] == '.'))\n            else:\n                dp[i][j] = dp[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == '.')\n    \n    return dp[m][n]",
    timeComplexity: "O(m × n)",
    spaceComplexity: "O(m × n)",
    notes: "DP: handle '*' by considering zero occurrences or one+ occurrences of preceding character."
  },
  {
    title: "Merge k Sorted Lists",
    description: "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
    difficulty: "Hard",
    topic: "Linked Lists",
    tags: ["linked-list", "divide-and-conquer", "heap", "merge-sort"],
    solution: "def mergeKLists(lists):\n    import heapq\n    heap = []\n    \n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(heap, (lst.val, i, lst))\n    \n    dummy = ListNode(0)\n    current = dummy\n    \n    while heap:\n        val, i, node = heapq.heappop(heap)\n        current.next = node\n        current = current.next\n        if node.next:\n            heapq.heappush(heap, (node.next.val, i, node.next))\n    \n    return dummy.next",
    timeComplexity: "O(n log k)",
    spaceComplexity: "O(k)",
    notes: "Use min-heap to always get smallest element among k list heads. Add next element when current is used."
  },
  {
    title: "Reverse Nodes in k-Group",
    description: "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.",
    difficulty: "Hard",
    topic: "Linked Lists",
    tags: ["linked-list", "recursion"],
    solution: "def reverseKGroup(head, k):\n    def reverse(start, end):\n        prev = end.next\n        current = start\n        while current != end:\n            next_temp = current.next\n            current.next = prev\n            prev = current\n            current = next_temp\n        return end\n    \n    dummy = ListNode(0)\n    dummy.next = head\n    group_prev = dummy\n    \n    while True:\n        kth = group_prev\n        for _ in range(k):\n            kth = kth.next\n            if not kth:\n                return dummy.next\n        \n        group_next = kth.next\n        first = group_prev.next\n        last = kth\n        \n        group_prev.next = reverse(first, last)\n        first.next = group_next\n        group_prev = first",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    notes: "Find k-length groups, reverse each group, and connect with previous and next groups."
  },
  {
    title: "Sudoku Solver",
    description: "Write a program to solve a Sudoku puzzle by filling the empty cells.",
    difficulty: "Hard",
    topic: "Backtracking",
    tags: ["array", "backtracking", "matrix"],
    solution: "def solveSudoku(board):\n    def is_valid(board, row, col, num):\n        for i in range(9):\n            if board[row][i] == num or board[i][col] == num:\n                return False\n        \n        start_row, start_col = 3 * (row // 3), 3 * (col // 3)\n        for i in range(3):\n            for j in range(3):\n                if board[start_row + i][start_col + j] == num:\n                    return False\n        return True\n    \n    def solve(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == '.':\n                    for num in '123456789':\n                        if is_valid(board, i, j, num):\n                            board[i][j] = num\n                            if solve(board):\n                                return True\n                            board[i][j] = '.'\n                    return False\n        return True\n    \n    solve(board)",
    timeComplexity: "O(9^(9×9))",
    spaceComplexity: "O(9×9)",
    notes: "Backtracking: try each number 1-9 in empty cells, backtrack if no valid solution found."
  },
  {
    title: "N-Queens",
    description: "The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.",
    difficulty: "Hard",
    topic: "Backtracking",
    tags: ["array", "backtracking"],
    solution: "def solveNQueens(n):\n    def is_safe(row, col):\n        for i in range(row):\n            if queens[i] == col or queens[i] - i == col - row or queens[i] + i == col + row:\n                return False\n        return True\n    \n    def backtrack(row):\n        if row == n:\n            board = ['.' * n for _ in range(n)]\n            for i in range(n):\n                board[i] = board[i][:queens[i]] + 'Q' + board[i][queens[i]+1:]\n            result.append(board)\n            return\n        \n        for col in range(n):\n            if is_safe(row, col):\n                queens[row] = col\n                backtrack(row + 1)\n    \n    result = []\n    queens = [-1] * n\n    backtrack(0)\n    return result",
    timeComplexity: "O(n!)",
    spaceComplexity: "O(n)",
    notes: "Backtracking: place queens row by row, check column and diagonal conflicts."
  },
  {
    title: "Wildcard Matching",
    description: "Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where '?' matches any single character and '*' matches any sequence of characters (including the empty sequence).",
    difficulty: "Hard",
    topic: "Dynamic Programming",
    tags: ["string", "dynamic-programming", "greedy", "recursion"],
    solution: "def isMatch(s, p):\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    \n    for j in range(1, n + 1):\n        if p[j-1] == '*':\n            dp[0][j] = dp[0][j-1]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j-1] == '*':\n                dp[i][j] = dp[i-1][j] or dp[i][j-1]\n            elif p[j-1] == '?' or s[i-1] == p[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n    \n    return dp[m][n]",
    timeComplexity: "O(m × n)",
    spaceComplexity: "O(m × n)",
    notes: "DP: '*' can match empty string or any character, '?' matches any single character."
  },
  {
    title: "Jump Game II",
    description: "Given an array of non-negative integers nums, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Your goal is to reach the last index in the minimum number of jumps.",
    difficulty: "Hard",
    topic: "Greedy",
    tags: ["array", "dynamic-programming", "greedy"],
    solution: "def jump(nums):\n    jumps = 0\n    current_end = 0\n    farthest = 0\n    \n    for i in range(len(nums) - 1):\n        farthest = max(farthest, i + nums[i])\n        if i == current_end:\n            jumps += 1\n            current_end = farthest\n    \n    return jumps",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    notes: "Greedy: track farthest reachable position in current jump level. Increment jumps when level ends."
  },
  {
    title: "Permutations II",
    description: "Given a collection of numbers, nums, that might contain duplicates, return all the unique permutations in any order.",
    difficulty: "Hard",
    topic: "Backtracking",
    tags: ["array", "backtracking"],
    solution: "def permuteUnique(nums):\n    def backtrack(current):\n        if len(current) == len(nums):\n            result.append(current[:])\n            return\n        \n        for i in range(len(nums)):\n            if used[i] or (i > 0 and nums[i] == nums[i-1] and not used[i-1]):\n                continue\n            used[i] = True\n            current.append(nums[i])\n            backtrack(current)\n            current.pop()\n            used[i] = False\n    \n    nums.sort()\n    used = [False] * len(nums)\n    result = []\n    backtrack([])\n    return result",
    timeComplexity: "O(n! × n)",
    spaceComplexity: "O(n)",
    notes: "Sort array, use boolean array to track usage, skip duplicates when previous same element not used."
  },
  {
    title: "Text Justification",
    description: "Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.",
    difficulty: "Hard",
    topic: "String",
    tags: ["array", "string", "simulation"],
    solution: "def fullJustify(words, maxWidth):\n    result = []\n    i = 0\n    \n    while i < len(words):\n        line = [words[i]]\n        length = len(words[i])\n        i += 1\n        \n        while i < len(words) and length + 1 + len(words[i]) <= maxWidth:\n            line.append(words[i])\n            length += 1 + len(words[i])\n            i += 1\n        \n        if i == len(words) or len(line) == 1:\n            justified = ' '.join(line).ljust(maxWidth)\n        else:\n            total_spaces = maxWidth - sum(len(word) for word in line)\n            gaps = len(line) - 1\n            space_per_gap = total_spaces // gaps\n            extra_spaces = total_spaces % gaps\n            \n            justified = ''\n            for j in range(len(line) - 1):\n                justified += line[j] + ' ' * space_per_gap\n                if j < extra_spaces:\n                    justified += ' '\n            justified += line[-1]\n        \n        result.append(justified)\n    \n    return result",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    notes: "Pack words into lines, distribute spaces evenly with extra spaces to leftmost gaps."
  },
  {
    title: "Edit Distance",
    description: "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You have the following three operations permitted on a word: Insert a character, Delete a character, Replace a character.",
    difficulty: "Hard",
    topic: "Dynamic Programming",
    tags: ["string", "dynamic-programming"],
    solution: "def minDistance(word1, word2):\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i-1] == word2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    \n    return dp[m][n]",
    timeComplexity: "O(m × n)",
    spaceComplexity: "O(m × n)",
    notes: "DP: if characters match, take diagonal value; else, 1 + min of (delete, insert, replace)."
  },
  {
    title: "Minimum Window Substring",
    description: "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window.",
    difficulty: "Hard",
    topic: "Sliding Window",
    tags: ["hash-table", "string", "sliding-window"],
    solution: "def minWindow(s, t):\n    from collections import Counter, defaultdict\n    \n    if not s or not t:\n        return ''\n    \n    required = Counter(t)\n    formed = 0\n    window_counts = defaultdict(int)\n    \n    left = right = 0\n    min_len = float('inf')\n    min_left = 0\n    \n    while right < len(s):\n        char = s[right]\n        window_counts[char] += 1\n        \n        if char in required and window_counts[char] == required[char]:\n            formed += 1\n        \n        while left <= right and formed == len(required):\n            if right - left + 1 < min_len:\n                min_len = right - left + 1\n                min_left = left\n            \n            char = s[left]\n            window_counts[char] -= 1\n            if char in required and window_counts[char] < required[char]:\n                formed -= 1\n            left += 1\n        \n        right += 1\n    \n    return '' if min_len == float('inf') else s[min_left:min_left + min_len]",
    timeComplexity: "O(|s| + |t|)",
    spaceComplexity: "O(|s| + |t|)",
    notes: "Sliding window: expand until valid, then contract while maintaining validity."
  },
  {
    title: "Largest Rectangle in Histogram",
    description: "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.",
    difficulty: "Hard",
    topic: "Stack",
    tags: ["array", "stack", "monotonic-stack"],
    solution: "def largestRectangleArea(heights):\n    stack = []\n    max_area = 0\n    \n    for i, h in enumerate(heights):\n        while stack and heights[stack[-1]] > h:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        stack.append(i)\n    \n    while stack:\n        height = heights[stack.pop()]\n        width = len(heights) if not stack else len(heights) - stack[-1] - 1\n        max_area = max(max_area, height * width)\n    \n    return max_area",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    notes: "Monotonic stack: when height decreases, calculate area using popped height as rectangle height."
  },
  {
    title: "Maximal Rectangle",
    description: "Given a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.",
    difficulty: "Hard",
    topic: "Stack",
    tags: ["array", "dynamic-programming", "stack", "matrix", "monotonic-stack"],
    solution: "def maximalRectangle(matrix):\n    if not matrix:\n        return 0\n    \n    def largestRectangleArea(heights):\n        stack = []\n        max_area = 0\n        for i, h in enumerate(heights):\n            while stack and heights[stack[-1]] > h:\n                height = heights[stack.pop()]\n                width = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, height * width)\n            stack.append(i)\n        \n        while stack:\n            height = heights[stack.pop()]\n            width = len(heights) if not stack else len(heights) - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        return max_area\n    \n    rows, cols = len(matrix), len(matrix[0])\n    heights = [0] * cols\n    max_area = 0\n    \n    for i in range(rows):\n        for j in range(cols):\n            heights[j] = heights[j] + 1 if matrix[i][j] == '1' else 0\n        max_area = max(max_area, largestRectangleArea(heights))\n    \n    return max_area",
    timeComplexity: "O(rows × cols)",
    spaceComplexity: "O(cols)",
    notes: "For each row, build histogram heights and find largest rectangle using stack-based solution."
  },
  {
    title: "Scramble String",
    description: "We can scramble a string s to get a string t using the following algorithm: If the length of the string is 1, stop. If the length of the string is > 1, split the string into two non-empty substrings at a random index, recursively scramble both substrings, and concatenate them in any order. Given two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.",
    difficulty: "Hard",
    topic: "Dynamic Programming",
    tags: ["string", "dynamic-programming"],
    solution: "def isScramble(s1, s2):\n    if len(s1) != len(s2):\n        return False\n    \n    n = len(s1)\n    dp = [[[False] * n for _ in range(n)] for _ in range(n + 1)]\n    \n    for i in range(n):\n        for j in range(n):\n            dp[1][i][j] = s1[i] == s2[j]\n    \n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            for j in range(n - length + 1):\n                for k in range(1, length):\n                    if (dp[k][i][j] and dp[length-k][i+k][j+k]) or \\\n                       (dp[k][i][j+length-k] and dp[length-k][i+k][j]):\n                        dp[length][i][j] = True\n                        break\n    \n    return dp[n][0][0]",
    timeComplexity: "O(n⁴)",
    spaceComplexity: "O(n³)",
    notes: "3D DP: check if substring s1[i:i+len] can be scrambled to s2[j:j+len] by trying all split points."
  },
  {
    title: "Merge Sorted Array",
    description: "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order.",
    difficulty: "Hard",
    topic: "Arrays",
    tags: ["array", "two-pointers", "sorting"],
    solution: "def merge(nums1, m, nums2, n):\n    i, j, k = m - 1, n - 1, m + n - 1\n    \n    while i >= 0 and j >= 0:\n        if nums1[i] > nums2[j]:\n            nums1[k] = nums1[i]\n            i -= 1\n        else:\n            nums1[k] = nums2[j]\n            j -= 1\n        k -= 1\n    \n    while j >= 0:\n        nums1[k] = nums2[j]\n        j -= 1\n        k -= 1",
    timeComplexity: "O(m + n)",
    spaceComplexity: "O(1)",
    notes: "Merge from end to avoid overwriting. Compare largest unplaced elements from both arrays."
  },
  {
    title: "Word Ladder",
    description: "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that: Every adjacent pair of words differs by a single letter and every si for 1 <= i <= k is in wordList. Given two words, beginWord and endWord, and a dictionary wordList, return the length of the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.",
    difficulty: "Hard",
    topic: "Graph",
    tags: ["hash-table", "string", "breadth-first-search"],
    solution: "def ladderLength(beginWord, endWord, wordList):\n    from collections import deque\n    \n    if endWord not in wordList:\n        return 0\n    \n    wordSet = set(wordList)\n    queue = deque([(beginWord, 1)])\n    visited = {beginWord}\n    \n    while queue:\n        word, length = queue.popleft()\n        \n        for i in range(len(word)):\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                new_word = word[:i] + c + word[i+1:]\n                \n                if new_word == endWord:\n                    return length + 1\n                \n                if new_word in wordSet and new_word not in visited:\n                    visited.add(new_word)\n                    queue.append((new_word, length + 1))\n    \n    return 0",
    timeComplexity: "O(M² × N)",
    spaceComplexity: "O(M × N)",
    notes: "BFS: try all single-character changes, add valid words to queue with incremented length."
  },
  {
    title: "Word Ladder II",
    description: "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk. Given two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord.",
    difficulty: "Hard",
    topic: "Graph",
    tags: ["hash-table", "string", "backtracking", "breadth-first-search"],
    solution: "def findLadders(beginWord, endWord, wordList):\n    from collections import deque, defaultdict\n    \n    if endWord not in wordList:\n        return []\n    \n    wordSet = set(wordList)\n    queue = deque([beginWord])\n    visited = {beginWord}\n    parent = defaultdict(list)\n    found = False\n    \n    while queue and not found:\n        current_visited = set()\n        \n        for _ in range(len(queue)):\n            word = queue.popleft()\n            \n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    new_word = word[:i] + c + word[i+1:]\n                    \n                    if new_word in wordSet and new_word not in visited:\n                        if new_word == endWord:\n                            found = True\n                        \n                        if new_word not in current_visited:\n                            current_visited.add(new_word)\n                            queue.append(new_word)\n                        \n                        parent[new_word].append(word)\n        \n        visited.update(current_visited)\n    \n    def build_path(word):\n        if word == beginWord:\n            return [[beginWord]]\n        \n        paths = []\n        for p in parent[word]:\n            for path in build_path(p):\n                paths.append(path + [word])\n        return paths\n    \n    return build_path(endWord) if found else []",
    timeComplexity: "O(M² × N)",
    spaceComplexity: "O(M × N)",
    notes: "BFS to find shortest path length, then backtrack from endWord using parent pointers to build all paths."
  },
  {
    title: "Longest Consecutive Sequence",
    description: "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.",
    difficulty: "Hard",
    topic: "Hash Table",
    tags: ["array", "hash-table", "union-find"],
    solution: "def longestConsecutive(nums):\n    num_set = set(nums)\n    longest = 0\n    \n    for num in num_set:\n        if num - 1 not in num_set:\n            current_num = num\n            current_length = 1\n            \n            while current_num + 1 in num_set:\n                current_num += 1\n                current_length += 1\n            \n            longest = max(longest, current_length)\n    \n    return longest",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    notes: "Use set for O(1) lookup. Only start counting from numbers that are beginning of sequences."
  },
  {
    title: "Word Break II",
    description: "Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.",
    difficulty: "Hard",
    topic: "Dynamic Programming",
    tags: ["hash-table", "string", "dynamic-programming", "backtracking", "trie", "memoization"],
    solution: "def wordBreak(s, wordDict):\n    def backtrack(start, memo):\n        if start in memo:\n            return memo[start]\n        \n        if start == len(s):\n            return [[]]\n        \n        result = []\n        for end in range(start + 1, len(s) + 1):\n            word = s[start:end]\n            if word in wordSet:\n                for sentence in backtrack(end, memo):\n                    result.append([word] + sentence)\n        \n        memo[start] = result\n        return result\n    \n    wordSet = set(wordDict)\n    sentences = backtrack(0, {})\n    return [' '.join(sentence) for sentence in sentences]",
    timeComplexity: "O(n² + 2ⁿ)",
    spaceComplexity: "O(2ⁿ)",
    notes: "Backtracking with memoization: try all possible word breaks, cache results to avoid recomputation."
  },
  {
    title: "Palindrome Partitioning II",
    description: "Given a string s, partition s such that every substring of the partition is a palindrome. Return the minimum cuts needed for a palindrome partitioning of s.",
    difficulty: "Hard",
    topic: "Dynamic Programming",
    tags: ["string", "dynamic-programming"],
    solution: "def minCut(s):\n    n = len(s)\n    is_palindrome = [[False] * n for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(i + 1):\n            if s[i] == s[j] and (i - j <= 2 or is_palindrome[j + 1][i - 1]):\n                is_palindrome[j][i] = True\n    \n    cuts = [0] * n\n    for i in range(n):\n        if is_palindrome[0][i]:\n            cuts[i] = 0\n        else:\n            cuts[i] = float('inf')\n            for j in range(i):\n                if is_palindrome[j + 1][i]:\n                    cuts[i] = min(cuts[i], cuts[j] + 1)\n    \n    return cuts[n - 1]",
    timeComplexity: "O(n²)",
    spaceComplexity: "O(n²)",
    notes: "Precompute palindrome table, then DP to find minimum cuts: cuts[i] = min(cuts[j] + 1) for all valid j."
  },
  {
    title: "Copy List with Random Pointer",
    description: "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list.",
    difficulty: "Hard",
    topic: "Linked Lists",
    tags: ["hash-table", "linked-list"],
    solution: "def copyRandomList(head):\n    if not head:\n        return None\n    \n    # Create new nodes and interweave with original\n    current = head\n    while current:\n        new_node = Node(current.val)\n        new_node.next = current.next\n        current.next = new_node\n        current = new_node.next\n    \n    # Set random pointers for new nodes\n    current = head\n    while current:\n        if current.random:\n            current.next.random = current.random.next\n        current = current.next.next\n    \n    # Separate the lists\n    dummy = Node(0)\n    new_current = dummy\n    current = head\n    \n    while current:\n        new_current.next = current.next\n        current.next = current.next.next\n        new_current = new_current.next\n        current = current.next\n    \n    return dummy.next",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    notes: "Interweave new nodes with original, copy random pointers, then separate the two lists."
  },
  {
    title: "LRU Cache",
    description: "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.",
    difficulty: "Hard",
    topic: "Design",
    tags: ["hash-table", "linked-list", "design", "doubly-linked-list"],
    solution: "class LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        \n        # Create dummy head and tail\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n    \n    def add_node(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def remove_node(self, node):\n        prev_node = node.prev\n        next_node = node.next\n        prev_node.next = next_node\n        next_node.prev = prev_node\n    \n    def move_to_head(self, node):\n        self.remove_node(node)\n        self.add_node(node)\n    \n    def pop_tail(self):\n        last_node = self.tail.prev\n        self.remove_node(last_node)\n        return last_node\n    \n    def get(self, key):\n        node = self.cache.get(key)\n        if node:\n            self.move_to_head(node)\n            return node.value\n        return -1\n    \n    def put(self, key, value):\n        node = self.cache.get(key)\n        if node:\n            node.value = value\n            self.move_to_head(node)\n        else:\n            new_node = Node(key, value)\n            if len(self.cache) >= self.capacity:\n                tail = self.pop_tail()\n                del self.cache[tail.key]\n            \n            self.cache[key] = new_node\n            self.add_node(new_node)",
    timeComplexity: "O(1)",
    spaceComplexity: "O(capacity)",
    notes: "Hash table + doubly linked list: hash table for O(1) access, DLL for O(1) insertion/deletion."
  },
  {
    title: "Insert Interval",
    description: "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval. Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals.",
    difficulty: "Hard",
    topic: "Arrays",
    tags: ["array"],
    solution: "def insert(intervals, newInterval):\n    result = []\n    i = 0\n    n = len(intervals)\n    \n    # Add all intervals that end before newInterval starts\n    while i < n and intervals[i][1] < newInterval[0]:\n        result.append(intervals[i])\n        i += 1\n    \n    # Merge overlapping intervals\n    while i < n and intervals[i][0] <= newInterval[1]:\n        newInterval[0] = min(newInterval[0], intervals[i][0])\n        newInterval[1] = max(newInterval[1], intervals[i][1])\n        i += 1\n    result.append(newInterval)\n    \n    # Add remaining intervals\n    while i < n:\n        result.append(intervals[i])\n        i += 1\n    \n    return result",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    notes: "Three phases: add non-overlapping intervals before, merge overlapping intervals, add remaining intervals."
  }
];
